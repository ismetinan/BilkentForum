// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: courses.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const listPostsByCourse = `-- name: ListPostsByCourse :many
SELECT 
  p.id,
  p.author_id,
  p.course_id,
  p.topic,
  p.created_at,
  p.updated_at,
  COALESCE(
    json_agg(
      json_build_object(
        'id', a.id,
        'url', a.file_url,
        'file_name', a.file_name,
        'mime_type', a.mime_type,
        'file_size', a.file_size
      )
    ) FILTER (WHERE a.id IS NOT NULL), '[]'
  ) AS attachments
FROM posts p
LEFT JOIN attachments a ON p.id = a.post_id
WHERE p.course_id = $1
GROUP BY p.id
ORDER BY p.created_at DESC
`

type ListPostsByCourseRow struct {
	ID          uuid.UUID
	AuthorID    uuid.UUID
	CourseID    string
	Topic       string
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	Attachments interface{}
}

func (q *Queries) ListPostsByCourse(ctx context.Context, courseID string) ([]ListPostsByCourseRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostsByCourse, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsByCourseRow
	for rows.Next() {
		var i ListPostsByCourseRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.CourseID,
			&i.Topic,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Attachments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
